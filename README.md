# Структура

* backend/app - сервис-конфигуратор, написанный на lumen
* stub-services - сервисы-заглушки, имитирующие rest и grpc сервисы с различными конфигурациями
* frontend - простой ui на реакте (UPD времени не хватило, тк застрял с grpc и его багом в локальном окружении)
* docker - вспомогательные файлы для docker-compose

# Установка

Так как кастомные образы не создаются (за исключением node для grpc), весь код
подключается чере volume, соответственно, перед запуском docker-compose необходимо
установить npm и composer зависимости.

- npm i
- cd backend && composer install
- docker-compose up -d

# Описание решения

Для общения с различными микросервисами создаются классы-клиенты, которые общаются с сервисами
по необходимым протоколам. Все эти классы-клиенты имплементируют один и тот же интерфейс.
В DI в настройках SettingsService-а выставляется массив аткуальных клиентов. SettingsService
итерируется по ним и, вызываю методы интерфейса, получает массив настроек.
После этого данные приводятся из vendor-специфик формата в формат Entity сервиса (вернее это DTO вышло на деле)
и отдается на фронтенд, где нужно отрисовать табличку. При изменении на фронтенде значения,
на бэкен отправляется запрос, в котором говорится какое значение менют, само значение настройки и инедтификатор сервиса.
По идентификатору сервиса фабрика создает конкретную реализацию СервисИнтерфейса.
Стоит заметить, что в данной реализации фабрика захардкожена руками, но в теории, при большом
количестве сервисов и/или их частом изменении - я бы использовал кодогенерацию, чтоб при 
в CI/CD пайплайне генерировалась фабркиа, на основе информации о текущих классах-сервисах.

# Заметки

**В задаче звучит "3 микросервиса", один из них - умеет только http. Не очень понял что имеется в виду, подумалось, что обработчики 
принимают форм-дату, но реализовывать в stub_services не стал, тк был неуверен. Но по сути 2 или 3 сервиса - 
разницы большой нет, подход к решению задачи  от этого не меняется**

1) В процессе реализации тестового grpc сервера столкнулся с проблемой запуска
сервера в докер-контейнере, нашел ишью, проблема не только у меня и пока что она не решена: 
https://github.com/grpc/grpc/issues/19430. Попытки решить ее самостоятельно за разумное время ни к чему
не привели, поэтому, к сожалению, проверить в деле grpc сервер не могу :(
Буду писать php-клиента как будто бы grpc-сервер на node.js работает.
Хотелось как раз потыркать grpc, поскольку никогда с ним дела не имел, вроде как разобрался,
жаль, что с багом столкнулся.

2) Стаб-серверы и докер файлы/компоуз, конечно, можно сделать лучше, конечно же,
но т.к. вы обращать внимание будете на другое - я сделал все на скорую руку для
локальной разработки.

3) В коде иногда делал какие-то заметки, чтобы показать ход своих мыслей.

4) Насчет тестов, юнит тесты здесь писать особого смысла не вижу. Разве что SettingsService, быть может.
Код простой, логики как таковой тут минимум, и юнит тесты тут были бы "ради самих тестов".
Я бы написал интеграционные тесты на Clients и API-тексты (тоже по сути интеграционные) на эндпоинты,
но, опять же, довольно много времени потратил на разборки с grpc (и баг и вообще разбираля с инструментов).

# Итог
Необходимый функционал реализован в полной мере, за исключение фронтенда, на который не хватило времени.
В задаче написано, что освновной  интерес представляет взаимодейсвие между сервисами, поэтому я решил, что
фронтом можно пожеровать и реализоваь только API для него.
Очень хотелось попробвоать grpc вживую, необходимый код сгенерирован и написан, но из-за бага настояющую реализаци
grpc-клиента пришлось заменить заглушкой.